# 模块二作业

**题目 01**
**请你用自己的语言介绍 Java 运行时数据区（内存区域）**

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

  **针对于jdk1.8**

  - 堆：剔除了元空间（Metaspace），内存划分为
    - 年轻代：用于存放用完就丢的对象空间，一般s和e区比值为1：1：8

      - survivor区域：用于存放gc后存活对象区域，通常称为to/from，执行gc后，会冲from把存活对象copy到to，如此往复。
      - eden区域：用于存放通常对象的区域，是gc主要回收的区域。

    - 老年代：用于存放存活比较久的对象或者大对象，回收不频繁。

  - 虚拟机栈：虚拟机栈为线程私有的空间，每个线程都会创建私有的栈内存，如果创建的线程的时候申请的不到内存创建虚拟机栈，会之间oom。虚拟机栈默认配置为Xss，默认是1m，通常每个方法执行的时候都会创建一个栈帧加入虚拟机栈中，如果线程递归过多就会抛出stackOverFlowError异常。

  - 本地方法栈：本地方法栈和虚拟机栈相似，区别就是虚拟机栈为虚拟机执行Java服务（字节码服务），而本地方法栈 为虚拟机使用到的Native方法（比如C++方法）服务。

  - 方法区： JDK1.8之前使用的方法区实现是永久代，JDK1.8及以后使用的方法区实现是元空间。

    方法区主要存储三种数据

    - class：类信息，方法信息，字段信息，方法表，静态变量（1.7后被移到堆中）
    - 运行时常量池/字符串常量池（1.7后被移到堆中）：字面类型，引用类型的内存地址
    - JIT编译器编译后的代码缓存：class对象

  - 运行时常量池（字符串常量池）

    - **class常量池：一个class文件只有一个class常量池** 
      - 字面量：数值型（int、float、long、double）、双引号引起来的字符串值等 
      - 符号引用：Class、Method、Field等 
    - **运行时常量池：一个class对象有一个运行时常量池** 
      - 字面量：数值型（int、float、long、double）、双引号引起来的字符串值等 
      - 符号引用：Class、Method、Field等 
    - **字符串常量池：全局只有一个字符串常量池** 
      - 双引号引起来的字符串值

  - 直接内存：不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。nio2可以直接使用直接内存，绕过jmm的限制直接写数据。

- 为什么堆内存要分年轻代和老年代？

  老年代和新生代空间比例一般是2：1

  首先主要是分代加说，但是实际上这样分只是为了对不同生命周期的对象做不同处理，从而达到减少stw的效果，提高程序的吞吐量

  年轻代的对象一般是用完就丢了，所以虚拟机在这块就使用**复制算法**，把仅存活的对象存入from/to的区域，这样可以快速回收空间而减少stw的时间。
  
  老年代对象一般是存活比较久的对象，所以虚拟机在这块空间是采用的**标记整理算法（无内存碎片）**，由于这种算法很耗时，所以一般用于gc回收不频繁的老年代。

**题目 02**
**描述一个 Java 对象的生命周期**

- 解释一个对象的创建过程

  - 通过new关键字创建对象
  - 常量池检查是否已经有这个class了，如果没有需要加载类
  - 判断类是否已经加载了，没有加载要加载类
  - 分配空间，通过指针碰撞或者空闲列表进行空间分配
  - 内存空间初始化初始值
  - 设置必要信息，设置对象头
  - 执行init方法
  - 结束
- 解释一个对象的内存分配

  - 一般是从年轻代分配空间，如果对象不够会触发ycg，然后分配空间，如果还不够，会触发内存担保，把对象之间放入老年代，如果这个时候老年代空间不够，则之间触发fullgc，回收老年代空间，再放入老年代，如果还不够，直接触发oom。
- 解释一个对象的销毁过程
- 可触及状态：对象正常被引用的时候
  - 可复活状态：当没有任何引用变量引用该对象的时候，对象进入此状态，垃圾回收器会准备回收此对象，然后会调用对象的 finalize() 方法，此方法可以导致对象重返**"可触及状态"**，此方法只会执行一次，下次再到此**”可复活状态“**时不会触发finalize() 方法，直接进入**”不可触及状态“**
- 不可触及状态：java虚拟机执行玩对象的finalize() 方法后没有重返**"可触及状态"**的状态，或者是已经执行过finalize() 方法。此状态等待gc回收。
- 对象的 2 种访问方式是什么？

  - 句柄：指放在堆中的对象的指针（指针的指针，比如List中存放的指针）
  - 直接指针：指放在虚拟机栈中对象的指针
- 为什么需要内存担保？

  - 由于jvm的内存分配机制，所以正常频繁回收的年轻代区域为三分之一，如果没有内存担保，那么能够创建的最大对象的大小为内存的三分之一（还要去掉s区），这样就会有很大问题，内存担保是为了解决这个问题。

**题目 03**
**垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？**

- ParNew 收集器
  - 配置参数： -XX:+UseParNewGC 
  - 配置参数： -XX:ParallelGCThreads=n 设置并行收集器收集时使用的并行收集线程数。一般最好和计算机的CPU相当 
    - 特点： 
    - 新生代并行（ParNew），
    - 老年代串行（Serial Old） Serial收集器的多线程版本 
    - 注意：单CPU性能并不如Serial，因为存在线程交互的开销
- ParallelScavenge 收集器
  - 配置参数： -XX:+UseParallelGC 
  - 目标是达到一个可控制的吞吐量（Throughput）。 
    - 特点： 吞吐量优先收集器 
    - 新生代使用并行回收收集器，采用复制算法 
    - 老年代使用串行收集器
- ParallelOld 收集器
  - 配置参数： -XX:+UseParallelOldGC 
    - 特点： 
    - Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 
    - 在注重吞吐量，CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
- CMS 收集器
  - 配置参数： -XX:+UseConcMarkSweepGC 应用CMS收集器。 
  - 尽管CMS收集器采用的是并发回收，但是在其初始标记和重新标记这两个阶段中仍然需要执行“STW”暂停程序中的工作线程，不过暂 停时间并不会太长，目前所有的垃圾收集器都做不到完全不需要“STW”，只是尽可能地缩短暂停时间。 
  - 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。另外，由于在垃圾收集阶段用户线程没 有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。
    -  特点: 
    - 低延迟：减少STW对用户体验的影响【响应时间和延迟要求高】 
    - 并发收集：可以同时执行用户线程 
    - CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行 回收。 
    - CMS收集器的垃圾收集算法采用的是标记-清除算法。 
    - 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。 
    - CMS收集器对CPU资源非常敏感。
- G1 收集器
  - Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region的内存布局形式。 
    - JDK 8以后G1收集器才被Oracle官方称为“全功能的垃圾收集器”。 
    - G1是一款面向服务端应用的垃圾收集器，大内存企业配置的垃圾收集器大多都是G1。
    -  JDK 9发布之日G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则被声明为不推 荐使用（Deprecate）。 
  - G1最大堆内存是 32MB*2048=64G ，G1最小堆内存 1MB*2048=2GB ，低于此值建议使用其它收集器。 
    - 特点：
      -  并行与并发：充分利用多核环境下的硬件优势 
      -  多代收集：不需要其他收集器配合就能独立管理整个GC堆 
      -  空间整合：“标记-整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片 
      -  可预测的停顿：能让使用者明确指定消耗在垃圾收集上的时间。当然，更短的GC时间的代价是回收空间的效率降低。